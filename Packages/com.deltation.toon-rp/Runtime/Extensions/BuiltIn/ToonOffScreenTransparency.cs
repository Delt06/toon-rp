using System;
using DELTation.ToonRP.Xr;
using UnityEngine;
using UnityEngine.Experimental.Rendering;
using UnityEngine.Rendering;
using static DELTation.ToonRP.Extensions.BuiltIn.ToonOffScreenTransparencySettings;

namespace DELTation.ToonRP.Extensions.BuiltIn
{
    public class ToonOffScreenTransparencyRender : ToonRenderingExtensionBase
    {
        private static readonly int ColorId = Shader.PropertyToID("_ToonRP_CompositeTransparency_Color");
        private static readonly int DepthId = Shader.PropertyToID("_ToonRP_CompositeTransparency_Depth");

        private readonly ToonDepthDownsample _depthDownsample = new();
        private readonly ToonDepthPrePass _depthPrePass = new(
            DepthId,
            0
        );
        private ToonAdditionalCameraData _additionalCameraData;
        private Camera _camera;
        private ToonCameraRendererSettings _cameraRendererSettings;
        private ToonCameraRenderTarget _cameraRenderTarget;
        private RenderTargetIdentifier _colorId;
        private CullingResults _cullingResults;
        private RenderTargetIdentifier _depthId;
        private ToonRenderingExtensionsCollection _extensionsCollection;
        private int _height;
        private ToonOffScreenTransparencySettings _settings;
        private ScriptableRenderContext _srpContext;
        private int _width;

        public override void Dispose()
        {
            base.Dispose();
            _depthDownsample.Dispose();
        }

        public override void Setup(in ToonRenderingExtensionContext context,
            IToonRenderingExtensionSettingsStorage settingsStorage)
        {
            base.Setup(in context, settingsStorage);
            _srpContext = context.ScriptableRenderContext;
            _cullingResults = context.CullingResults;
            _settings = settingsStorage.GetSettings<ToonOffScreenTransparencySettings>(this);
            _camera = context.Camera;
            _cameraRendererSettings = context.CameraRendererSettings;
            _cameraRenderTarget = context.CameraRenderTarget;
            _extensionsCollection = context.Collection;
            _additionalCameraData = context.AdditionalCameraData;

            _width = Mathf.Max(1, _cameraRenderTarget.Width / _settings.ResolutionFactor);
            _height = Mathf.Max(1, _cameraRenderTarget.Height / _settings.ResolutionFactor);
            _colorId = default;
            _depthId = default;
        }

        public override void Render()
        {
            CommandBuffer cmd = CommandBufferPool.Get();

            string passName = !string.IsNullOrWhiteSpace(_settings.PassName)
                ? _settings.PassName
                : DefaultPassName;
            using (new ProfilingScope(cmd, NamedProfilingSampler.Get(passName)))
            {
                _srpContext.ExecuteCommandBufferAndClear(cmd);
                ToonXr.BeginXrRendering(ref _srpContext, cmd, _additionalCameraData.XrPass);

                if (_settings.DepthMode == DepthRenderMode.PrePass)
                {
                    const bool stencil = true;

                    var renderContext = new ToonDepthPrePass.RenderContext(_srpContext, _cullingResults, _camera,
                        _additionalCameraData, _cameraRendererSettings, _extensionsCollection, PrePassMode.Depth,
                        _width, _height, stencil
                    );
                    _depthPrePass.Render(ref renderContext);
                }

                using (new ProfilingScope(cmd, NamedProfilingSampler.Get("Render Transparent Geometry")))
                {
                    {
                        var colorDesc =
                            new RenderTextureDescriptor(_width, _height, _cameraRenderTarget.ColorFormat, 0);
                        _colorId = GetTemporaryRT(cmd, ColorId, colorDesc, FilterMode.Bilinear);
                        if (_settings.DepthMode == DepthRenderMode.Downsample)
                        {
                            var depthDesc = new RenderTextureDescriptor(_width, _height, GraphicsFormat.None, 24);
                            _depthId = GetTemporaryRT(cmd, DepthId, depthDesc, FilterMode.Point);
                        }
                        else
                        {
                            // Depth is generated by the depth pre-pass.
                            _depthId = ToonRpUtils.FixupTextureArrayIdentifier(DepthId);
                        }

                        cmd.SetRenderTarget(_colorId, RenderBufferLoadAction.DontCare, RenderBufferStoreAction.Store,
                            _depthId, RenderBufferLoadAction.Load, RenderBufferStoreAction.Store
                        );
                        cmd.ClearRenderTarget(false, true, Color.black);
                        if (_settings.DepthMode == DepthRenderMode.Downsample)
                        {
                            bool highQuality = _settings.DepthDownsampleQuality == DepthDownsampleQualityLevel.High;
                            _depthDownsample.Downsample(cmd, highQuality, _settings.ResolutionFactor);
                        }
                    }

                    var screenParams = new ToonCameraRenderTarget.ScreenParams(_width, _height)
                    {
                        SetViewportRect = false,
                    };
                    _cameraRenderTarget.SetScreenParamsOverride(cmd, screenParams);
                    _srpContext.ExecuteCommandBufferAndClear(cmd);

                    {
                        var sortingSettings = new SortingSettings(_camera)
                        {
                            criteria = SortingCriteria.CommonTransparent,
                        };
                        // See 23-3: https://developer.nvidia.com/gpugems/gpugems3/part-iv-image-effects/chapter-23-high-speed-screen-particles
                        RenderTargetBlendState renderTargetBlendState = _settings.BlendMode switch
                        {
                            TransparencyBlendMode.Alpha => new RenderTargetBlendState(
                                sourceColorBlendMode: BlendMode.SrcAlpha,
                                destinationColorBlendMode: BlendMode.OneMinusSrcAlpha,
                                sourceAlphaBlendMode: BlendMode.Zero,
                                destinationAlphaBlendMode: BlendMode.OneMinusSrcAlpha
                            ),
                            TransparencyBlendMode.Additive => new RenderTargetBlendState(
                                sourceColorBlendMode: BlendMode.One, destinationColorBlendMode: BlendMode.One
                            ),
                            _ => throw new ArgumentOutOfRangeException(),
                        };
                        const bool includesTransparent = true;
                        ToonCameraRenderer.DrawGeometry(_cameraRendererSettings,
                            ref _srpContext, _cullingResults, sortingSettings, RenderQueueRange.transparent,
                            includesTransparent,
                            _settings.LayerMask,
                            new RenderStateBlock(RenderStateMask.Blend)
                            {
                                blendState = new BlendState
                                {
                                    blendState0 = renderTargetBlendState,
                                },
                            }
                        );
                    }
                }

                ToonXr.EndXrRendering(ref _srpContext, cmd, _additionalCameraData.XrPass);
            }

            _srpContext.ExecuteCommandBufferAndClear(cmd);
            CommandBufferPool.Release(cmd);
        }

        public override void Cleanup()
        {
            base.Cleanup();

            CommandBuffer cmd = CommandBufferPool.Get();

            cmd.ReleaseTemporaryRT(ColorId);
            switch (_settings.DepthMode)
            {
                case DepthRenderMode.Downsample:
                    cmd.ReleaseTemporaryRT(DepthId);
                    break;
                case DepthRenderMode.PrePass:
                    _depthPrePass.Cleanup(ref _srpContext);
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }

            _srpContext.ExecuteCommandBufferAndClear(cmd);
            CommandBufferPool.Release(cmd);
        }

        private RenderTargetIdentifier GetTemporaryRT(CommandBuffer cmd,
            int identifier, RenderTextureDescriptor descriptor, FilterMode filterMode)
        {
#if ENABLE_VR && ENABLE_XR_MODULE
            XRPass xrPass = _additionalCameraData.XrPass;
            if (xrPass.enabled)
            {
                int arraySize = xrPass.viewCount;
                cmd.GetTemporaryRTArray(identifier, descriptor.width, descriptor.height, arraySize,
                    descriptor.depthBufferBits, filterMode, descriptor.graphicsFormat
                );
                return ToonRpUtils.FixupTextureArrayIdentifier(identifier);
            }
#endif // ENABLE_VR && ENABLE_XR_MODULE

            cmd.GetTemporaryRT(identifier, descriptor, filterMode);
            return identifier;
        }
    }

    public class ToonOffScreenTransparencyCompose : ToonRenderingExtensionBase
    {
        public const string ShaderName = "Hidden/Toon RP/Off-Screen Transparency";
        private static readonly int TintId = Shader.PropertyToID("_Tint");
        private static readonly int PatternId = Shader.PropertyToID("_Pattern");
        private static readonly int PatternHorizontalTilingId = Shader.PropertyToID("_PatternHorizontalTiling");
        private static readonly int HeightOverWidthId = Shader.PropertyToID("_HeightOverWidth");
        private static readonly int BlendSrcId = Shader.PropertyToID("_BlendSrc");
        private static readonly int BlendDstId = Shader.PropertyToID("_BlendDst");

        private readonly ToonPipelineMaterial _material = new(ShaderName, "Toon RP Off-Screen Transparency");
        private Camera _camera;
        private ToonCameraRenderTarget _cameraRenderTarget;
        private int _height;
        private ToonOffScreenTransparencySettings _settings;
        private ScriptableRenderContext _srpContext;
        private int _width;

        public override void Dispose()
        {
            base.Dispose();
            _material.Dispose();
        }

        public override void Setup(in ToonRenderingExtensionContext context,
            IToonRenderingExtensionSettingsStorage settingsStorage)
        {
            base.Setup(in context, settingsStorage);
            _srpContext = context.ScriptableRenderContext;
            _settings = settingsStorage.GetSettings<ToonOffScreenTransparencySettings>(this);
            _camera = context.Camera;
            _cameraRenderTarget = context.CameraRenderTarget;

            _width = Mathf.Max(1, _cameraRenderTarget.Width / _settings.ResolutionFactor);
            _height = Mathf.Max(1, _cameraRenderTarget.Height / _settings.ResolutionFactor);
        }

        public override void Render()
        {
            CommandBuffer cmd = CommandBufferPool.Get();

            string passName = !string.IsNullOrWhiteSpace(_settings.PassName)
                ? _settings.PassName
                : DefaultPassName;
            using (new ProfilingScope(cmd, NamedProfilingSampler.Get(passName)))
            {
                using (new ProfilingScope(cmd, NamedProfilingSampler.Get("Compose with Camera Render Target")))
                {
                    Material material = _material.GetOrCreate();

                    material.SetVector(TintId, _settings.Tint);
                    material.SetTexture(PatternId,
                        _settings.Pattern != null ? _settings.Pattern : Texture2D.whiteTexture
                    );
                    material.SetFloat(PatternHorizontalTilingId, _settings.PatternHorizontalTiling);
                    material.SetFloat(HeightOverWidthId, (float) _height / _width);

                    (BlendMode blendSource, BlendMode blendDestination) = _settings.BlendMode switch
                    {
                        TransparencyBlendMode.Alpha => (BlendMode.OneMinusSrcAlpha, BlendMode.SrcAlpha),
                        TransparencyBlendMode.Additive => (BlendMode.One, BlendMode.One),
                        _ => throw new ArgumentOutOfRangeException(),
                    };
                    material.SetFloat(BlendSrcId, (float) blendSource);
                    material.SetFloat(BlendDstId, (float) blendDestination);

                    bool renderToTexture = _cameraRenderTarget.RenderToTexture || _camera.targetTexture != null;
                    ToonBlitter.Blit(cmd, material, renderToTexture, 0);
                }
            }

            _srpContext.ExecuteCommandBufferAndClear(cmd);
            CommandBufferPool.Release(cmd);
        }
    }
}